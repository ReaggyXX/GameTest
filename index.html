<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Map with Multiplayer</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif;
        }
        canvas { 
            display: block; 
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
        #playerName {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px;
            background-color: rgba(0,0,0,0.5);
            color: white;
            border-radius: 5px;
        }
        #playerList {
            position: absolute;
            top: 60px;
            right: 10px;
            padding: 10px;
            background-color: rgba(0,0,0,0.5);
            color: white;
            border-radius: 5px;
            max-height: 300px;
            overflow-y: auto;
        }
        #statusIndicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: red;
            display: inline-block;
            margin-right: 5px;
        }
        .online {
            background-color: #00ff00 !important;
        }
        .mobileButton {
            width: 40px;
            height: 40px;
            background-color: rgba(0,0,0,0.5);
            color: white;
            border: 1px solid white;
            border-radius: 5px;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
        }
        
        #mobileJump {
            width: 100%;
        }
        
        @media (max-width: 768px) {
            #mobileControls, #lookControls {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div id="info">
        WASD to move, Mouse to look around
        <div>Status: <span id="statusIndicator"></span> <span id="statusText">Connecting...</span></div>
    </div>
    <div id="playerName">
        <input type="text" id="nameInput" placeholder="Enter your name">
        <button id="setName">Set Name</button>
    </div>
    <div id="playerList">
        <h3>Players Online</h3>
        <ul id="players"></ul>
    </div>
    <div id="chatContainer" style="position: absolute; left: 10px; bottom: 10px; width: 300px; background-color: rgba(0,0,0,0.5); color: white; border-radius: 5px; padding: 10px; display: flex; flex-direction: column;">
        <div id="chatMessages" style="height: 150px; overflow-y: auto; margin-bottom: 10px;"></div>
        <div style="display: flex;">
            <input type="text" id="chatInput" placeholder="Type a message..." style="flex-grow: 1; padding: 5px; border-radius: 3px; border: none; margin-right: 5px;">
            <button id="sendChat" style="padding: 5px 10px; border-radius: 3px; border: none; background-color: #4CAF50; color: white;">Send</button>
        </div>
    </div>

    <div id="mobileControls" style="position: absolute; bottom: 170px; left: 10px; display: none;">
        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; grid-gap: 5px; width: 150px;">
            <button id="mobileUp" class="mobileButton" style="grid-column: 2; grid-row: 1;">↑</button>
            <button id="mobileLeft" class="mobileButton" style="grid-column: 1; grid-row: 2;">←</button>
            <button id="mobileDown" class="mobileButton" style="grid-column: 2; grid-row: 2;">↓</button>
            <button id="mobileRight" class="mobileButton" style="grid-column: 3; grid-row: 2;">→</button>
            <button id="mobileJump" class="mobileButton" style="grid-column: 2; grid-row: 3;">Jump</button>
        </div>
    </div>

    <div id="lookControls" style="position: absolute; bottom: 170px; right: 10px; display: none;">
        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; grid-gap: 5px; width: 150px;">
            <button id="lookUp" class="mobileButton" style="grid-column: 2; grid-row: 1;">↑</button>
            <button id="lookLeft" class="mobileButton" style="grid-column: 1; grid-row: 2;">←</button>
            <button id="lookDown" class="mobileButton" style="grid-column: 2; grid-row: 2;">↓</button>
            <button id="lookRight" class="mobileButton" style="grid-column: 3; grid-row: 2;">→</button>
        </div>
    </div>

    <div id="controlToggle" style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background-color: rgba(0,0,0,0.5); color: white; padding: 5px 10px; border-radius: 5px; cursor: pointer;">
        Toggle Mobile Controls
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="character.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb); // Sky blue background
        
        // Camera setup
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 5);
        
        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);
        
        // Ground
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x336633,
            side: THREE.DoubleSide
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);
        
        // Add buildings
        function createBuilding(x, z, width, height, depth, color) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({ color: color });
            const building = new THREE.Mesh(geometry, material);
            building.position.set(x, height/2, z);
            scene.add(building);
            return building;
        }
        
        // Create some buildings
        createBuilding(-10, -10, 5, 8, 5, 0x8888ff);
        createBuilding(10, -8, 4, 5, 4, 0xff8888);
        createBuilding(-8, 12, 6, 10, 6, 0x88ff88);
        createBuilding(12, 10, 8, 15, 8, 0xffff88);
        
        // Add trees
        function createTree(x, z) {
            // Tree trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, 1, z);
            
            // Tree top
            const topGeometry = new THREE.ConeGeometry(2, 4, 8);
            const topMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.set(x, 4, z);
            
            scene.add(trunk);
            scene.add(top);
        }
        
        // Create some trees
        createTree(-15, 0);
        createTree(15, 5);
        createTree(0, 15);
        createTree(-5, -15);
        createTree(20, -20);
        
        // Movement controls
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        
        let canJump = true;
        let velocity = 0;
        const gravity = 0.2;
        let isJumping = false;
        
        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('keyup', onKeyUp, false);
        
        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': 
                    if (canJump) {
                        velocity = 0.5; // Jump velocity
                        canJump = false;
                        isJumping = true;
                    }
                    break;
            }
        }
        
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
            }
        }
        
        // Mouse look controls
        let isMouseLocked = false;
        
        renderer.domElement.addEventListener('click', function() {
            if (!isMouseLocked) {
                renderer.domElement.requestPointerLock();
            }
        });
        
        document.addEventListener('pointerlockchange', function() {
            isMouseLocked = document.pointerLockElement === renderer.domElement;
        });
        
        let pitch = 0;
        let yaw = 0;
        
        document.addEventListener('mousemove', function(event) {
            if (isMouseLocked) {
                yaw -= event.movementX * 0.002;
                pitch -= event.movementY * 0.002;
                
                // Clamp pitch to avoid flipping
                pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
            }
        });
        
        // Multiplayer
        const playerColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
        let players = {};
        let playerMeshes = {};
        let playerName = localStorage.getItem('playerName') || "Player" + Math.floor(Math.random() * 1000);
        let playerColor = parseInt(localStorage.getItem('playerColor')) || playerColors[Math.floor(Math.random() * playerColors.length)];
        let sessionId = null;
        let isConnected = false;
        let socket = null;
        
        // Character data
        let playerCharacter = null;
        
        // Try to load character from localStorage
        const savedCharacterData = localStorage.getItem('playerCharacter');
        if (savedCharacterData) {
            try {
                const characterData = JSON.parse(savedCharacterData);
                playerCharacter = Character.fromJSON(characterData);
                // Update name and color if they've changed
                playerCharacter.name = playerName;
                playerCharacter.color = playerColor;
            } catch (e) {
                console.error('Error loading character data:', e);
                playerCharacter = new Character(playerName, playerColor);
            }
        } else {
            playerCharacter = new Character(playerName, playerColor);
        }
        
        // Add character stats UI
        const characterStatsDiv = document.createElement('div');
        characterStatsDiv.id = 'characterStats';
        characterStatsDiv.style.position = 'absolute';
        characterStatsDiv.style.left = '10px';
        characterStatsDiv.style.top = '100px';
        characterStatsDiv.style.backgroundColor = 'rgba(0,0,0,0.5)';
        characterStatsDiv.style.color = 'white';
        characterStatsDiv.style.padding = '10px';
        characterStatsDiv.style.borderRadius = '5px';
        characterStatsDiv.style.maxWidth = '200px';
        document.body.appendChild(characterStatsDiv);
        
        function updateCharacterStatsUI() {
            characterStatsDiv.innerHTML = `
                <h3>Character Stats</h3>
                <div>Level: ${playerCharacter.level}</div>
                <div>XP: ${playerCharacter.experience}/${playerCharacter.experienceToNextLevel}</div>
                <div>Health: ${Math.floor(playerCharacter.currentHealth)}/${playerCharacter.maxHealth}</div>
                <div>Mana: ${Math.floor(playerCharacter.currentMana)}/${playerCharacter.maxMana}</div>
                <div>Strength: ${playerCharacter.strength}</div>
                <div>Defense: ${playerCharacter.defense}</div>
                <div>Speed: ${playerCharacter.speed}</div>
            `;
        }
        
        // Update character stats initially
        updateCharacterStatsUI();
        
        // Save character data periodically
        setInterval(() => {
            localStorage.setItem('playerCharacter', JSON.stringify(playerCharacter.toJSON()));
        }, 10000); // Save every 10 seconds
        
        // Connection status
        const statusIndicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');
        
        // Set player name
        document.getElementById('nameInput').value = playerName;
        document.getElementById('setName').addEventListener('click', function() {
            const newName = document.getElementById('nameInput').value.trim();
            if (newName) {
                playerName = newName;
                localStorage.setItem('playerName', playerName);
                registerPlayer();
            }
        });
        
        // Server communication
        function connectWebSocket() {
            // Get the current host and use secure WebSocket if on HTTPS
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}`;
            
            statusText.textContent = 'Connecting...';
            socket = new WebSocket(wsUrl);
            
            socket.onopen = function() {
                console.log('WebSocket connected');
                    isConnected = true;
                    statusIndicator.classList.add('online');
                    statusText.textContent = 'Connected';
                registerPlayer();
            };
            
            socket.onclose = function() {
                console.log('WebSocket disconnected');
                isConnected = false;
                statusIndicator.classList.remove('online');
                statusText.textContent = 'Disconnected';
                setTimeout(connectWebSocket, 3000); // Try to reconnect
            };
            
            socket.onerror = function(error) {
                console.error('WebSocket error:', error);
                isConnected = false;
                statusIndicator.classList.remove('online');
                statusText.textContent = 'Connection error';
            };
            
            socket.onmessage = function(event) {
                const data = JSON.parse(event.data);
                
                if (data.type === 'registered') {
                    sessionId = data.id;
                    console.log('Registered with server, session ID:', sessionId);
                    
                    // Send character data to server
                    socket.send(JSON.stringify({
                        type: 'characterData',
                        id: sessionId,
                        character: playerCharacter.toJSON()
                    }));
                } else if (data.type === 'players') {
                    updatePlayersList(data.players);
                } else if (data.type === 'chat') {
                    // Display chat message
                    const messageElement = document.createElement('div');
                    messageElement.innerHTML = `<strong>${data.name}:</strong> ${data.message}`;
                    chatMessages.appendChild(messageElement);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                    
                    // Also display chat bubble above player
                    if (data.name !== playerName && playerMeshes[data.name]) {
                        showChatBubble(data.name, data.message);
                    }
                } else if (data.type === 'characterUpdate') {
                    // Handle character updates from server
                    if (data.id === sessionId) {
                        // Update our character with server data
                        playerCharacter = Character.fromJSON(data.character);
                        updateCharacterStatsUI();
                    }
                }
            };
        }
        
        function registerPlayer() {
            if (!socket || socket.readyState !== WebSocket.OPEN) return;
            
            // If we already have a session ID, send an update instead of registering again
            if (sessionId) {
                socket.send(JSON.stringify({
                    type: 'rename',
                    id: sessionId,
                    name: playerName
                }));
                } else {
                socket.send(JSON.stringify({
                    type: 'register',
                    name: playerName,
                    x: camera.position.x,
                    y: camera.position.y,
                    z: camera.position.z,
                    color: playerColor,
                    rotation: yaw
                }));
            }
        }
        
        function updatePlayerPosition() {
            if (!socket || socket.readyState !== WebSocket.OPEN || !sessionId) return;
            
            socket.send(JSON.stringify({
                type: 'update',
                id: sessionId,
                x: camera.position.x,
                y: camera.position.y,
                z: camera.position.z,
                rotation: yaw,
                jumping: isJumping
            }));
        }
        
        function updatePlayersList(playersList) {
            // Clear old players
            players = {};
            
            // Update players from server data
            playersList.forEach(player => {
                if (player.id !== sessionId) {
                    players[player.name] = {
                        x: player.x,
                        y: player.y,
                        z: player.z,
                        color: player.color,
                        rotation: player.rotation
                    };
                }
            });
            
            // Add yourself to the players list
            players[playerName] = {
                x: camera.position.x,
                y: camera.position.y,
                z: camera.position.z,
                color: playerColor,
                rotation: yaw
            };
            
            updatePlayerList();
        }
        
        function updatePlayerMeshes() {
            // Remove old meshes
            for (const name in playerMeshes) {
                if (!players[name]) {
                    scene.remove(playerMeshes[name]);
                    delete playerMeshes[name];
                }
            }
            
            // Update or add meshes
            for (const name in players) {
                if (name === playerName) continue; // Skip self
                
                const player = players[name];
                
                if (!playerMeshes[name]) {
                    // Create player mesh using cylinder for body and sphere for head
                    const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8);
                    const headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                    
                    const material = new THREE.MeshStandardMaterial({ color: player.color });
                    
                    const body = new THREE.Mesh(bodyGeometry, material);
                    const head = new THREE.Mesh(headGeometry, material);
                    
                    head.position.y = 1.0;
                    
                    // Create a group to hold the body parts
                    const playerGroup = new THREE.Group();
                    playerGroup.add(body);
                    playerGroup.add(head);
                    
                    // Add name label
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 256;
                    canvas.height = 64;
                    context.font = '24px Arial';
                    context.fillStyle = '#ffffff';
                    context.textAlign = 'center';
                    context.fillText(name, 128, 24);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const labelMaterial = new THREE.SpriteMaterial({
                        map: texture,
                        transparent: true
                    });
                    const label = new THREE.Sprite(labelMaterial);
                    label.position.y = 2.5;
                    label.scale.set(5, 1.25, 1);
                    
                    playerGroup.add(label);
                    
                    scene.add(playerGroup);
                    playerMeshes[name] = playerGroup;
                }
                
                // Update position
                playerMeshes[name].position.set(player.x, player.y, player.z);
                
                // Update rotation (assume players look in direction of movement)
                if (player.rotation !== undefined) {
                    playerMeshes[name].rotation.y = player.rotation;
                }
            }
        }
        
        function updatePlayerList() {
            const playersList = document.getElementById('players');
            playersList.innerHTML = '';
            
            for (const name in players) {
                const li = document.createElement('li');
                if (name === playerName) {
                    li.textContent = name + ' (You)';
                    li.style.color = '#' + players[name].color.toString(16).padStart(6, '0');
                    li.style.fontWeight = 'bold';
                } else {
                    li.textContent = name;
                    li.style.color = '#' + players[name].color.toString(16).padStart(6, '0');
                }
                playersList.appendChild(li);
            }
            
            // Add yourself if not in list
            if (!players[playerName]) {
                const li = document.createElement('li');
                li.textContent = playerName + ' (You)';
                li.style.color = '#' + playerColor.toString(16).padStart(6, '0');
                li.style.fontWeight = 'bold';
                playersList.appendChild(li);
            }
        }
        
        // Animation loop
        const clock = new THREE.Clock();
        let lastUpdateTime = 0;
        let lastCharacterUpdateTime = 0;
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();
            const moveSpeed = 5 * delta;
            
            // Update character stats
            playerCharacter.update();
            
            // Update character UI every 0.5 seconds
            if (elapsedTime - lastCharacterUpdateTime > 0.5) {
                updateCharacterStatsUI();
                lastCharacterUpdateTime = elapsedTime;
            }
            
            // Update camera rotation from mouse
            camera.rotation.order = 'YXZ';
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;
            
            // Calculate movement direction
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            
            const sideDirection = new THREE.Vector3(-direction.z, 0, direction.x);
            
            // Apply movement
            if (moveForward) camera.position.addScaledVector(direction, moveSpeed);
            if (moveBackward) camera.position.addScaledVector(direction, -moveSpeed);
            if (moveLeft) camera.position.addScaledVector(sideDirection, -moveSpeed);
            if (moveRight) camera.position.addScaledVector(sideDirection, moveSpeed);
            
            // Handle jumping and gravity
            if (isJumping) {
                camera.position.y += velocity;
                velocity -= gravity * delta * 10;
                
                // Check if we've landed
                if (camera.position.y <= 2) {
                    camera.position.y = 2;
                    velocity = 0;
                    isJumping = false;
                    canJump = true;
                }
            } else {
                // Keep player on the ground when not jumping
            camera.position.y = 2;
            }
            
            // Update server with player position (limit frequency)
            if (elapsedTime - lastUpdateTime > 0.1) { // Update every 100ms
                updatePlayerPosition();
                lastUpdateTime = elapsedTime;
            }
            
            // Update player meshes
            updatePlayerMeshes();
            
            renderer.render(scene, camera);
        }
        
        // Start animation
        animate();
        
        // Resize handler
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize player in the local players object
        players[playerName] = {
            x: camera.position.x,
            y: camera.position.y,
            z: camera.position.z,
            color: playerColor
        };
        updatePlayerList();
        
        // Start server communication
        connectWebSocket();
        
        // Handle page visibility changes
        document.addEventListener('visibilitychange', function() {
            if (document.visibilityState === 'visible') {
                // When tab becomes active again, reconnect if needed
                if (!isConnected) {
                    connectWebSocket();
                }
            }
        });
        
        // Clean up on page unload
        window.addEventListener('beforeunload', function() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.close();
            }
        });

        // Chat functionality
        const chatInput = document.getElementById('chatInput');
        const chatMessages = document.getElementById('chatMessages');
        const sendChatButton = document.getElementById('sendChat');

        // Send chat message when Send button is clicked
        sendChatButton.addEventListener('click', sendChatMessage);

        // Send chat message when Enter key is pressed in chat input
        chatInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                sendChatMessage();
            }
        });

        function sendChatMessage() {
            const message = chatInput.value.trim();
            if (message && socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    type: 'chat',
                    id: sessionId,
                    name: playerName,
                    message: message
                }));
                chatInput.value = '';
            }
        }

        // Function to show chat bubble above player
        function showChatBubble(playerName, message) {
            if (!playerMeshes[playerName]) return;
            
            // Remove existing chat bubble if any
            const existingBubble = playerMeshes[playerName].getObjectByName('chatBubble');
            if (existingBubble) {
                playerMeshes[playerName].remove(existingBubble);
            }
            
            // Create chat bubble
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;
            
            // Draw bubble background
            context.fillStyle = 'rgba(255, 255, 255, 0.8)';
            context.strokeStyle = '#000000';
            context.lineWidth = 2;
            roundRect(context, 10, 10, canvas.width - 20, canvas.height - 20, 10, true, true);
            
            // Draw text
            context.font = '16px Arial';
            context.fillStyle = '#000000';
            context.textAlign = 'center';
            
            // Word wrap the message
            const words = message.split(' ');
            let line = '';
            let y = 40;
            for (let i = 0; i < words.length; i++) {
                const testLine = line + words[i] + ' ';
                const metrics = context.measureText(testLine);
                if (metrics.width > canvas.width - 40 && i > 0) {
                    context.fillText(line, canvas.width / 2, y);
                    line = words[i] + ' ';
                    y += 20;
                } else {
                    line = testLine;
                }
            }
            context.fillText(line, canvas.width / 2, y);
            
            // Create sprite with the canvas texture
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true
            });
            const sprite = new THREE.Sprite(material);
            sprite.name = 'chatBubble';
            sprite.position.y = 3.5;
            sprite.scale.set(5, 2.5, 1);
            
            playerMeshes[playerName].add(sprite);
            
            // Remove bubble after 5 seconds
            setTimeout(() => {
                if (playerMeshes[playerName]) {
                    const bubble = playerMeshes[playerName].getObjectByName('chatBubble');
                    if (bubble) {
                        playerMeshes[playerName].remove(bubble);
                    }
                }
            }, 5000);
        }

        // Helper function to draw rounded rectangles
        function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            if (fill) {
                ctx.fill();
            }
            if (stroke) {
                ctx.stroke();
            }
        }

        // Mobile controls
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const mobileControls = document.getElementById('mobileControls');
        const lookControls = document.getElementById('lookControls');
        const controlToggle = document.getElementById('controlToggle');

        // Show mobile controls by default on mobile devices
        if (isMobile) {
            mobileControls.style.display = 'block';
            lookControls.style.display = 'block';
            
            // Make info text smaller on mobile
            document.getElementById('info').style.fontSize = '12px';
        }

        // Toggle mobile controls visibility
        controlToggle.addEventListener('click', function() {
            if (mobileControls.style.display === 'none') {
                mobileControls.style.display = 'block';
                lookControls.style.display = 'block';
            } else {
                mobileControls.style.display = 'none';
                lookControls.style.display = 'none';
            }
        });

        // Movement buttons
        const mobileUp = document.getElementById('mobileUp');
        const mobileDown = document.getElementById('mobileDown');
        const mobileLeft = document.getElementById('mobileLeft');
        const mobileRight = document.getElementById('mobileRight');
        const mobileJump = document.getElementById('mobileJump');

        // Look buttons
        const lookUp = document.getElementById('lookUp');
        const lookDown = document.getElementById('lookDown');
        const lookLeft = document.getElementById('lookLeft');
        const lookRight = document.getElementById('lookRight');

        // Touch events for movement buttons
        mobileUp.addEventListener('touchstart', function(e) {
            e.preventDefault();
            moveForward = true;
        });
        mobileUp.addEventListener('touchend', function() {
            moveForward = false;
        });

        mobileDown.addEventListener('touchstart', function(e) {
            e.preventDefault();
            moveBackward = true;
        });
        mobileDown.addEventListener('touchend', function() {
            moveBackward = false;
        });

        mobileLeft.addEventListener('touchstart', function(e) {
            e.preventDefault();
            moveLeft = true;
        });
        mobileLeft.addEventListener('touchend', function() {
            moveLeft = false;
        });

        mobileRight.addEventListener('touchstart', function(e) {
            e.preventDefault();
            moveRight = true;
        });
        mobileRight.addEventListener('touchend', function() {
            moveRight = false;
        });

        mobileJump.addEventListener('touchstart', function(e) {
            e.preventDefault();
            if (canJump) {
                velocity = 0.5;
                canJump = false;
                isJumping = true;
            }
        });

        // Look controls
        const lookSensitivity = 0.05;

        // Replace the existing look control event listeners with these improved versions
        lookUp.addEventListener('touchstart', function(e) {
            e.preventDefault();
            const lookInterval = setInterval(function() {
                pitch -= lookSensitivity;
                pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
            }, 16); // ~60fps
            
            function stopLooking() {
                clearInterval(lookInterval);
            }
            
            lookUp.addEventListener('touchend', stopLooking);
            lookUp.addEventListener('touchcancel', stopLooking);
        });

        lookDown.addEventListener('touchstart', function(e) {
            e.preventDefault();
            const lookInterval = setInterval(function() {
                pitch += lookSensitivity;
                pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
            }, 16);
            
            function stopLooking() {
                clearInterval(lookInterval);
            }
            
            lookDown.addEventListener('touchend', stopLooking);
            lookDown.addEventListener('touchcancel', stopLooking);
        });

        lookLeft.addEventListener('touchstart', function(e) {
            e.preventDefault();
            const lookInterval = setInterval(function() {
                yaw += lookSensitivity;
            }, 16);
            
            function stopLooking() {
                clearInterval(lookInterval);
            }
            
            lookLeft.addEventListener('touchend', stopLooking);
            lookLeft.addEventListener('touchcancel', stopLooking);
        });

        lookRight.addEventListener('touchstart', function(e) {
            e.preventDefault();
            const lookInterval = setInterval(function() {
                yaw -= lookSensitivity;
            }, 16);
            
            function stopLooking() {
                clearInterval(lookInterval);
            }
            
            lookRight.addEventListener('touchend', stopLooking);
            lookRight.addEventListener('touchcancel', stopLooking);
        });

        // Also update the mouse controls for desktop testing
        lookUp.addEventListener('mousedown', function() {
            const lookInterval = setInterval(function() {
                pitch -= lookSensitivity;
                pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
            }, 16);
            
            function stopLooking() {
                clearInterval(lookInterval);
            }
            
            lookUp.addEventListener('mouseup', stopLooking);
            lookUp.addEventListener('mouseleave', stopLooking);
        });

        lookDown.addEventListener('mousedown', function() {
            const lookInterval = setInterval(function() {
                pitch += lookSensitivity;
                pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
            }, 16);
            
            function stopLooking() {
                clearInterval(lookInterval);
            }
            
            lookDown.addEventListener('mouseup', stopLooking);
            lookDown.addEventListener('mouseleave', stopLooking);
        });

        lookLeft.addEventListener('mousedown', function() {
            const lookInterval = setInterval(function() {
                yaw += lookSensitivity;
            }, 16);
            
            function stopLooking() {
                clearInterval(lookInterval);
            }
            
            lookLeft.addEventListener('mouseup', stopLooking);
            lookLeft.addEventListener('mouseleave', stopLooking);
        });

        lookRight.addEventListener('mousedown', function() {
            const lookInterval = setInterval(function() {
                yaw -= lookSensitivity;
            }, 16);
            
            function stopLooking() {
                clearInterval(lookInterval);
            }
            
            lookRight.addEventListener('mouseup', stopLooking);
            lookRight.addEventListener('mouseleave', stopLooking);
        });

        // Update info text to include mobile controls info
        if (isMobile) {
            document.getElementById('info').innerHTML = 
                'Use on-screen controls to move and look around<br>' +
                '<div>Status: <span id="statusIndicator"></span> <span id="statusText">Connecting...</span></div>';
        }
    </script>
</body>
</html>
