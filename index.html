<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Map with Multiplayer</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif;
        }
        canvas { 
            display: block; 
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
        #playerName {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px;
            background-color: rgba(0,0,0,0.5);
            color: white;
            border-radius: 5px;
        }
        #playerList {
            position: absolute;
            top: 60px;
            right: 10px;
            padding: 10px;
            background-color: rgba(0,0,0,0.5);
            color: white;
            border-radius: 5px;
            max-height: 300px;
            overflow-y: auto;
        }
        #statusIndicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: red;
            display: inline-block;
            margin-right: 5px;
        }
        .online {
            background-color: #00ff00 !important;
        }
        .mobileButton {
            width: 40px;
            height: 40px;
            background-color: rgba(0,0,0,0.5);
            color: white;
            border: 1px solid white;
            border-radius: 5px;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
        }
        
        #mobileJump {
            width: 100%;
        }
        
        @media (max-width: 768px) {
            #mobileControls, #lookControls {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div id="info">
        WASD to move, Mouse to look around
        <div>Status: <span id="statusIndicator"></span> <span id="statusText">Connecting...</span></div>
    </div>
    <div id="playerName">
        <input type="text" id="nameInput" placeholder="Enter your name">
        <button id="setName">Set Name</button>
    </div>
    <div id="playerList">
        <h3>Players Online</h3>
        <ul id="players"></ul>
    </div>
    <div id="chatContainer" style="position: absolute; left: 10px; bottom: 10px; width: 300px; background-color: rgba(0,0,0,0.5); color: white; border-radius: 5px; padding: 10px; display: flex; flex-direction: column;">
        <div id="chatMessages" style="height: 150px; overflow-y: auto; margin-bottom: 10px;"></div>
        <div style="display: flex;">
            <input type="text" id="chatInput" placeholder="Type a message..." style="flex-grow: 1; padding: 5px; border-radius: 3px; border: none; margin-right: 5px;">
            <button id="sendChat" style="padding: 5px 10px; border-radius: 3px; border: none; background-color: #4CAF50; color: white;">Send</button>
        </div>
    </div>

    <div id="mobileControls" style="position: absolute; bottom: 170px; left: 10px; display: none;">
        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; grid-gap: 5px; width: 150px;">
            <button id="mobileUp" class="mobileButton" style="grid-column: 2; grid-row: 1;">↑</button>
            <button id="mobileLeft" class="mobileButton" style="grid-column: 1; grid-row: 2;">←</button>
            <button id="mobileDown" class="mobileButton" style="grid-column: 2; grid-row: 2;">↓</button>
            <button id="mobileRight" class="mobileButton" style="grid-column: 3; grid-row: 2;">→</button>
            <button id="mobileJump" class="mobileButton" style="grid-column: 2; grid-row: 3;">Jump</button>
        </div>
    </div>

    <div id="lookControls" style="position: absolute; bottom: 170px; right: 10px; display: none;">
        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; grid-gap: 5px; width: 150px;">
            <button id="lookUp" class="mobileButton" style="grid-column: 2; grid-row: 1;">↑</button>
            <button id="lookLeft" class="mobileButton" style="grid-column: 1; grid-row: 2;">←</button>
            <button id="lookDown" class="mobileButton" style="grid-column: 2; grid-row: 2;">↓</button>
            <button id="lookRight" class="mobileButton" style="grid-column: 3; grid-row: 2;">→</button>
        </div>
    </div>

    <div id="controlToggle" style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background-color: rgba(0,0,0,0.5); color: white; padding: 5px 10px; border-radius: 5px; cursor: pointer;">
        Toggle Mobile Controls
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb); // Sky blue background
        
        // Camera setup
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 5);
        
        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);
        
        // Terrain
        const terrainSize = 500;
        const terrainResolution = 128;
        const terrainGeometry = new THREE.PlaneGeometry(
            terrainSize, 
            terrainSize, 
            terrainResolution - 1, 
            terrainResolution - 1
        );
        
        // Generate heightmap
        function generateTerrain() {
            const positions = terrainGeometry.attributes.position.array;
            const simplex = new SimplexNoise();
            
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const z = positions[i + 2];
                
                // Multiple layers of noise for more natural terrain
                let height = 0;
                height += 15 * simplex.noise2D(x / 100, z / 100); // Large features
                height += 5 * simplex.noise2D(x / 50, z / 50);    // Medium features
                height += 2 * simplex.noise2D(x / 20, z / 20);    // Small features
                
                // Flatten the center area a bit for player spawn
                const distFromCenter = Math.sqrt(x * x + z * z);
                const flatteningFactor = Math.min(1, distFromCenter / 30);
                
                positions[i + 1] = height * flatteningFactor;
            }
            
            terrainGeometry.computeVertexNormals();
            return positions;
        }
        
        // Create terrain material with texture
        const terrainMaterial = new THREE.MeshStandardMaterial({
            vertexColors: true,
            flatShading: false
        });
        
        // Add color based on height
        function colorTerrain(positions) {
            const colors = [];
            
            for (let i = 0; i < positions.length; i += 3) {
                const height = positions[i + 1];
                
                let color = new THREE.Color();
                
                if (height < -5) {
                    // Deep water
                    color.setRGB(0.1, 0.3, 0.6);
                } else if (height < 0) {
                    // Shallow water
                    color.setRGB(0.2, 0.5, 0.8);
                } else if (height < 1) {
                    // Sand
                    color.setRGB(0.9, 0.8, 0.6);
                } else if (height < 5) {
                    // Grass
                    color.setRGB(0.2, 0.6, 0.2);
                } else if (height < 10) {
                    // Forest
                    color.setRGB(0.1, 0.4, 0.1);
                } else {
                    // Mountain
                    const gray = 0.4 + 0.4 * (Math.min(height, 20) / 20);
                    color.setRGB(gray, gray, gray);
                }
                
                colors.push(color.r, color.g, color.b);
            }
            
            terrainGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        }
        
        // Generate and color the terrain
        const terrainPositions = generateTerrain();
        colorTerrain(terrainPositions);
        
        // Create the terrain mesh
        const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
        terrain.rotation.x = -Math.PI / 2;
        terrain.position.y = -2; // Lower the terrain a bit
        scene.add(terrain);
        
        // Add a water plane
        const waterGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize);
        const waterMaterial = new THREE.MeshStandardMaterial({
            color: 0x0099ff,
            transparent: true,
            opacity: 0.7
        });
        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        water.rotation.x = -Math.PI / 2;
        water.position.y = -1; // Water level
        scene.add(water);
        
        // Add forests (clusters of trees)
        function createForest(centerX, centerZ, numTrees, radius) {
            for (let i = 0; i < numTrees; i++) {
                // Random position within the radius
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * radius;
                const x = centerX + Math.cos(angle) * distance;
                const z = centerZ + Math.sin(angle) * distance;
                
                // Sample height at this position
                const sampleX = (x / terrainSize) * terrainResolution;
                const sampleZ = (z / terrainSize) * terrainResolution;
                const idx = Math.floor(sampleX) + Math.floor(sampleZ) * terrainResolution;
                let height = 0;
                
                if (idx >= 0 && idx < terrainPositions.length / 3) {
                    height = terrainPositions[idx * 3 + 1];
                }
                
                // Only place trees on appropriate terrain
                if (height > 1 && height < 10) {
                    createTree(x, z, height - 2);
                }
            }
        }
        
        // Update tree creation function to use the terrain height
        function createTree(x, z, groundHeight = 0) {
            // Tree trunk
            const trunkHeight = 2 + Math.random() * 3;
            const trunkGeometry = new THREE.CylinderGeometry(0.2 + Math.random() * 0.3, 0.3 + Math.random() * 0.5, trunkHeight, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, groundHeight + trunkHeight/2, z);
            
            // Tree top (multiple layers for more realistic trees)
            const layers = 2 + Math.floor(Math.random() * 3);
            const treeGroup = new THREE.Group();
            treeGroup.add(trunk);
            
            const treeColor = new THREE.Color(0.1 + Math.random() * 0.1, 0.4 + Math.random() * 0.2, 0.1);
            
            for (let i = 0; i < layers; i++) {
                const topHeight = 1.5 + Math.random();
                const topRadius = 1 + Math.random() * (layers - i) * 0.4;
                const topGeometry = new THREE.ConeGeometry(topRadius, topHeight, 8);
                const topMaterial = new THREE.MeshStandardMaterial({ color: treeColor });
            const top = new THREE.Mesh(topGeometry, topMaterial);
                top.position.set(x, groundHeight + trunkHeight + i * topHeight * 0.7, z);
                treeGroup.add(top);
            }
            
            scene.add(treeGroup);
            return treeGroup;
        }
        
        // Create mountain ranges
        function createMountainRange(centerX, centerZ, numPeaks, radius, maxHeight) {
            for (let i = 0; i < numPeaks; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * radius;
                const x = centerX + Math.cos(angle) * distance;
                const z = centerZ + Math.sin(angle) * distance;
                const height = maxHeight * 0.5 + Math.random() * maxHeight * 0.5;
                
                createMountainPeak(x, z, height);
            }
        }
        
        function createMountainPeak(x, z, height) {
            const radiusTop = 0;
            const radiusBottom = 10 + Math.random() * 15;
            const mountainGeometry = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, 8);
            
            // Create gradient material for mountain
            const mountainColor = new THREE.Color(0.4 + Math.random() * 0.2, 0.4 + Math.random() * 0.2, 0.4 + Math.random() * 0.2);
            const mountainMaterial = new THREE.MeshStandardMaterial({ color: mountainColor });
            
            const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
            mountain.position.set(x, height/2 - 2, z); // Adjust height to match terrain
            scene.add(mountain);
        }
        
        // Create several forests
        createForest(-50, -50, 100, 30);
        createForest(70, 40, 80, 25);
        createForest(0, 100, 120, 40);
        createForest(-80, 60, 90, 35);
        createForest(100, -70, 70, 30);
        
        // Create mountain ranges
        createMountainRange(-100, -100, 5, 40, 50);
        createMountainRange(120, 80, 7, 50, 60);
        createMountainRange(-80, 120, 4, 30, 40);
        
        // Movement controls
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        
        let canJump = true;
        let velocity = 0;
        const gravity = 0.2;
        let isJumping = false;
        
        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('keyup', onKeyUp, false);
        
        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': 
                    if (canJump) {
                        velocity = 0.5; // Jump velocity
                        canJump = false;
                        isJumping = true;
                    }
                    break;
            }
        }
        
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
            }
        }
        
        // Mouse look controls
        let isMouseLocked = false;
        
        renderer.domElement.addEventListener('click', function() {
            if (!isMouseLocked) {
                renderer.domElement.requestPointerLock();
            }
        });
        
        document.addEventListener('pointerlockchange', function() {
            isMouseLocked = document.pointerLockElement === renderer.domElement;
        });
        
        let pitch = 0;
        let yaw = 0;
        
        document.addEventListener('mousemove', function(event) {
            if (isMouseLocked) {
                yaw -= event.movementX * 0.002;
                pitch -= event.movementY * 0.002;
                
                // Clamp pitch to avoid flipping
                pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
            }
        });
        
        // Multiplayer
        const playerColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
        let players = {};
        let playerMeshes = {};
        let playerName = localStorage.getItem('playerName') || "Player" + Math.floor(Math.random() * 1000);
        let playerColor = parseInt(localStorage.getItem('playerColor')) || playerColors[Math.floor(Math.random() * playerColors.length)];
        let sessionId = null;
        let isConnected = false;
        let socket = null;
        
        // Connection status
        const statusIndicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');
        
        // Set player name
        document.getElementById('nameInput').value = playerName;
        document.getElementById('setName').addEventListener('click', function() {
            const newName = document.getElementById('nameInput').value.trim();
            if (newName) {
                playerName = newName;
                localStorage.setItem('playerName', playerName);
                registerPlayer();
            }
        });
        
        // Server communication
        function connectWebSocket() {
            // Get the current host and use secure WebSocket if on HTTPS
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}`;
            
            statusText.textContent = 'Connecting...';
            socket = new WebSocket(wsUrl);
            
            socket.onopen = function() {
                console.log('WebSocket connected');
                    isConnected = true;
                    statusIndicator.classList.add('online');
                    statusText.textContent = 'Connected';
                registerPlayer();
            };
            
            socket.onclose = function() {
                console.log('WebSocket disconnected');
                isConnected = false;
                statusIndicator.classList.remove('online');
                statusText.textContent = 'Disconnected';
                setTimeout(connectWebSocket, 3000); // Try to reconnect
            };
            
            socket.onerror = function(error) {
                console.error('WebSocket error:', error);
                isConnected = false;
                statusIndicator.classList.remove('online');
                statusText.textContent = 'Connection error';
            };
            
            socket.onmessage = function(event) {
                const data = JSON.parse(event.data);
                
                if (data.type === 'registered') {
                    sessionId = data.id;
                    console.log('Registered with server, session ID:', sessionId);
                } else if (data.type === 'players') {
                    updatePlayersList(data.players);
                } else if (data.type === 'chat') {
                    // Display chat message
                    const messageElement = document.createElement('div');
                    messageElement.innerHTML = `<strong>${data.name}:</strong> ${data.message}`;
                    chatMessages.appendChild(messageElement);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                    
                    // Also display chat bubble above player
                    if (data.name !== playerName && playerMeshes[data.name]) {
                        showChatBubble(data.name, data.message);
                    }
                }
            };
        }
        
        function registerPlayer() {
            if (!socket || socket.readyState !== WebSocket.OPEN) return;
            
            // If we already have a session ID, send an update instead of registering again
            if (sessionId) {
                socket.send(JSON.stringify({
                    type: 'rename',
                    id: sessionId,
                    name: playerName
                }));
                } else {
                socket.send(JSON.stringify({
                    type: 'register',
                    name: playerName,
                    x: camera.position.x,
                    y: camera.position.y,
                    z: camera.position.z,
                    color: playerColor,
                    rotation: yaw
                }));
            }
        }
        
        function updatePlayerPosition() {
            if (!socket || socket.readyState !== WebSocket.OPEN || !sessionId) return;
            
            socket.send(JSON.stringify({
                type: 'update',
                id: sessionId,
                x: camera.position.x,
                y: camera.position.y,
                z: camera.position.z,
                rotation: yaw,
                jumping: isJumping
            }));
        }
        
        function updatePlayersList(playersList) {
            // Clear old players
            players = {};
            
            // Update players from server data
            playersList.forEach(player => {
                if (player.id !== sessionId) {
                    players[player.name] = {
                        x: player.x,
                        y: player.y,
                        z: player.z,
                        color: player.color,
                        rotation: player.rotation
                    };
                }
            });
            
            // Add yourself to the players list
            players[playerName] = {
                x: camera.position.x,
                y: camera.position.y,
                z: camera.position.z,
                color: playerColor,
                rotation: yaw
            };
            
            updatePlayerList();
        }
        
        function updatePlayerMeshes() {
            // Remove old meshes
            for (const name in playerMeshes) {
                if (!players[name]) {
                    scene.remove(playerMeshes[name]);
                    delete playerMeshes[name];
                }
            }
            
            // Update or add meshes
            for (const name in players) {
                if (name === playerName) continue; // Skip self
                
                const player = players[name];
                
                if (!playerMeshes[name]) {
                    // Create player mesh using cylinder for body and sphere for head
                    const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8);
                    const headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                    
                    const material = new THREE.MeshStandardMaterial({ color: player.color });
                    
                    const body = new THREE.Mesh(bodyGeometry, material);
                    const head = new THREE.Mesh(headGeometry, material);
                    
                    head.position.y = 1.0;
                    
                    // Create a group to hold the body parts
                    const playerGroup = new THREE.Group();
                    playerGroup.add(body);
                    playerGroup.add(head);
                    
                    // Add name label
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 256;
                    canvas.height = 64;
                    context.font = '24px Arial';
                    context.fillStyle = '#ffffff';
                    context.textAlign = 'center';
                    context.fillText(name, 128, 24);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const labelMaterial = new THREE.SpriteMaterial({
                        map: texture,
                        transparent: true
                    });
                    const label = new THREE.Sprite(labelMaterial);
                    label.position.y = 2.5;
                    label.scale.set(5, 1.25, 1);
                    
                    playerGroup.add(label);
                    
                    scene.add(playerGroup);
                    playerMeshes[name] = playerGroup;
                }
                
                // Update position
                playerMeshes[name].position.set(player.x, player.y, player.z);
                
                // Update rotation (assume players look in direction of movement)
                if (player.rotation !== undefined) {
                    playerMeshes[name].rotation.y = player.rotation;
                }
            }
        }
        
        function updatePlayerList() {
            const playersList = document.getElementById('players');
            playersList.innerHTML = '';
            
            for (const name in players) {
                const li = document.createElement('li');
                if (name === playerName) {
                    li.textContent = name + ' (You)';
                    li.style.color = '#' + players[name].color.toString(16).padStart(6, '0');
                    li.style.fontWeight = 'bold';
                } else {
                    li.textContent = name;
                    li.style.color = '#' + players[name].color.toString(16).padStart(6, '0');
                }
                playersList.appendChild(li);
            }
            
            // Add yourself if not in list
            if (!players[playerName]) {
                const li = document.createElement('li');
                li.textContent = playerName + ' (You)';
                li.style.color = '#' + playerColor.toString(16).padStart(6, '0');
                li.style.fontWeight = 'bold';
                playersList.appendChild(li);
            }
        }
        
        // Animation loop
        const clock = new THREE.Clock();
        let lastUpdateTime = 0;
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();
            const moveSpeed = 5 * delta;
            
            // Update camera rotation from mouse
            camera.rotation.order = 'YXZ';
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;
            
            // Calculate movement direction
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            
            const sideDirection = new THREE.Vector3(-direction.z, 0, direction.x);
            
            // Apply movement
            if (moveForward) camera.position.addScaledVector(direction, moveSpeed);
            if (moveBackward) camera.position.addScaledVector(direction, -moveSpeed);
            if (moveLeft) camera.position.addScaledVector(sideDirection, -moveSpeed);
            if (moveRight) camera.position.addScaledVector(sideDirection, moveSpeed);
            
            // Get terrain height at player position
            const terrainX = (camera.position.x / terrainSize + 0.5) * terrainResolution;
            const terrainZ = (camera.position.z / terrainSize + 0.5) * terrainResolution;
            
            // Find the closest vertices in the terrain
            const x0 = Math.floor(terrainX);
            const z0 = Math.floor(terrainZ);
            const x1 = Math.min(x0 + 1, terrainResolution - 1);
            const z1 = Math.min(z0 + 1, terrainResolution - 1);
            
            // Get heights at the four corners
            const getHeight = (x, z) => {
                const idx = (z * terrainResolution + x) * 3 + 1;
                return terrainPositions[idx];
            };
            
            const h00 = getHeight(x0, z0);
            const h10 = getHeight(x1, z0);
            const h01 = getHeight(x0, z1);
            const h11 = getHeight(x1, z1);
            
            // Bilinear interpolation to get height at exact position
            const fx = terrainX - x0;
            const fz = terrainZ - z0;
            
            const h0 = h00 * (1 - fx) + h10 * fx;
            const h1 = h01 * (1 - fx) + h11 * fx;
            const terrainHeight = h0 * (1 - fz) + h1 * fz;
            
            // Handle jumping and gravity with terrain height
            if (isJumping) {
                camera.position.y += velocity;
                velocity -= gravity * delta * 10;
                
                // Check if we've landed on terrain
                const groundLevel = terrainHeight + 2; // Player height offset
                if (camera.position.y <= groundLevel) {
                    camera.position.y = groundLevel;
                    velocity = 0;
                    isJumping = false;
                    canJump = true;
                }
            } else {
                // Keep player on the terrain when not jumping
                camera.position.y = terrainHeight + 2; // Player height offset
            }
            
            // Update server with player position (limit frequency)
            if (elapsedTime - lastUpdateTime > 0.1) { // Update every 100ms
                updatePlayerPosition();
                lastUpdateTime = elapsedTime;
            }
            
            // Update player meshes
            updatePlayerMeshes();
            
            renderer.render(scene, camera);
        }
        
        // Start animation
        animate();
        
        // Resize handler
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize player in the local players object
        players[playerName] = {
            x: camera.position.x,
            y: camera.position.y,
            z: camera.position.z,
            color: playerColor
        };
        updatePlayerList();
        
        // Start server communication
        connectWebSocket();
        
        // Handle page visibility changes
        document.addEventListener('visibilitychange', function() {
            if (document.visibilityState === 'visible') {
                // When tab becomes active again, reconnect if needed
                if (!isConnected) {
                    connectWebSocket();
                }
            }
        });
        
        // Clean up on page unload
        window.addEventListener('beforeunload', function() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.close();
            }
        });

        // Chat functionality
        const chatInput = document.getElementById('chatInput');
        const chatMessages = document.getElementById('chatMessages');
        const sendChatButton = document.getElementById('sendChat');

        // Send chat message when Send button is clicked
        sendChatButton.addEventListener('click', sendChatMessage);

        // Send chat message when Enter key is pressed in chat input
        chatInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                sendChatMessage();
            }
        });

        function sendChatMessage() {
            const message = chatInput.value.trim();
            if (message && socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    type: 'chat',
                    id: sessionId,
                    name: playerName,
                    message: message
                }));
                chatInput.value = '';
            }
        }

        // Function to show chat bubble above player
        function showChatBubble(playerName, message) {
            if (!playerMeshes[playerName]) return;
            
            // Remove existing chat bubble if any
            const existingBubble = playerMeshes[playerName].getObjectByName('chatBubble');
            if (existingBubble) {
                playerMeshes[playerName].remove(existingBubble);
            }
            
            // Create chat bubble
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;
            
            // Draw bubble background
            context.fillStyle = 'rgba(255, 255, 255, 0.8)';
            context.strokeStyle = '#000000';
            context.lineWidth = 2;
            roundRect(context, 10, 10, canvas.width - 20, canvas.height - 20, 10, true, true);
            
            // Draw text
            context.font = '16px Arial';
            context.fillStyle = '#000000';
            context.textAlign = 'center';
            
            // Word wrap the message
            const words = message.split(' ');
            let line = '';
            let y = 40;
            for (let i = 0; i < words.length; i++) {
                const testLine = line + words[i] + ' ';
                const metrics = context.measureText(testLine);
                if (metrics.width > canvas.width - 40 && i > 0) {
                    context.fillText(line, canvas.width / 2, y);
                    line = words[i] + ' ';
                    y += 20;
                } else {
                    line = testLine;
                }
            }
            context.fillText(line, canvas.width / 2, y);
            
            // Create sprite with the canvas texture
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true
            });
            const sprite = new THREE.Sprite(material);
            sprite.name = 'chatBubble';
            sprite.position.y = 3.5;
            sprite.scale.set(5, 2.5, 1);
            
            playerMeshes[playerName].add(sprite);
            
            // Remove bubble after 5 seconds
            setTimeout(() => {
                if (playerMeshes[playerName]) {
                    const bubble = playerMeshes[playerName].getObjectByName('chatBubble');
                    if (bubble) {
                        playerMeshes[playerName].remove(bubble);
                    }
                }
            }, 5000);
        }

        // Helper function to draw rounded rectangles
        function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            if (fill) {
                ctx.fill();
            }
            if (stroke) {
                ctx.stroke();
            }
        }

        // Mobile controls
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const mobileControls = document.getElementById('mobileControls');
        const lookControls = document.getElementById('lookControls');
        const controlToggle = document.getElementById('controlToggle');

        // Show mobile controls by default on mobile devices
        if (isMobile) {
            mobileControls.style.display = 'block';
            lookControls.style.display = 'block';
            
            // Make info text smaller on mobile
            document.getElementById('info').style.fontSize = '12px';
        }

        // Toggle mobile controls visibility
        controlToggle.addEventListener('click', function() {
            if (mobileControls.style.display === 'none') {
                mobileControls.style.display = 'block';
                lookControls.style.display = 'block';
            } else {
                mobileControls.style.display = 'none';
                lookControls.style.display = 'none';
            }
        });

        // Movement buttons
        const mobileUp = document.getElementById('mobileUp');
        const mobileDown = document.getElementById('mobileDown');
        const mobileLeft = document.getElementById('mobileLeft');
        const mobileRight = document.getElementById('mobileRight');
        const mobileJump = document.getElementById('mobileJump');

        // Look buttons
        const lookUp = document.getElementById('lookUp');
        const lookDown = document.getElementById('lookDown');
        const lookLeft = document.getElementById('lookLeft');
        const lookRight = document.getElementById('lookRight');

        // Touch events for movement buttons
        mobileUp.addEventListener('touchstart', function(e) {
            e.preventDefault();
            moveForward = true;
        });
        mobileUp.addEventListener('touchend', function() {
            moveForward = false;
        });

        mobileDown.addEventListener('touchstart', function(e) {
            e.preventDefault();
            moveBackward = true;
        });
        mobileDown.addEventListener('touchend', function() {
            moveBackward = false;
        });

        mobileLeft.addEventListener('touchstart', function(e) {
            e.preventDefault();
            moveLeft = true;
        });
        mobileLeft.addEventListener('touchend', function() {
            moveLeft = false;
        });

        mobileRight.addEventListener('touchstart', function(e) {
            e.preventDefault();
            moveRight = true;
        });
        mobileRight.addEventListener('touchend', function() {
            moveRight = false;
        });

        mobileJump.addEventListener('touchstart', function(e) {
            e.preventDefault();
            if (canJump) {
                velocity = 0.5;
                canJump = false;
                isJumping = true;
            }
        });

        // Look controls
        const lookSensitivity = 0.05;

        // Replace the existing look control event listeners with these improved versions
        lookUp.addEventListener('touchstart', function(e) {
            e.preventDefault();
            const lookInterval = setInterval(function() {
                pitch -= lookSensitivity;
                pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
            }, 16); // ~60fps
            
            function stopLooking() {
                clearInterval(lookInterval);
            }
            
            lookUp.addEventListener('touchend', stopLooking);
            lookUp.addEventListener('touchcancel', stopLooking);
        });

        lookDown.addEventListener('touchstart', function(e) {
            e.preventDefault();
            const lookInterval = setInterval(function() {
                pitch += lookSensitivity;
                pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
            }, 16);
            
            function stopLooking() {
                clearInterval(lookInterval);
            }
            
            lookDown.addEventListener('touchend', stopLooking);
            lookDown.addEventListener('touchcancel', stopLooking);
        });

        lookLeft.addEventListener('touchstart', function(e) {
            e.preventDefault();
            const lookInterval = setInterval(function() {
                yaw += lookSensitivity;
            }, 16);
            
            function stopLooking() {
                clearInterval(lookInterval);
            }
            
            lookLeft.addEventListener('touchend', stopLooking);
            lookLeft.addEventListener('touchcancel', stopLooking);
        });

        lookRight.addEventListener('touchstart', function(e) {
            e.preventDefault();
            const lookInterval = setInterval(function() {
                yaw -= lookSensitivity;
            }, 16);
            
            function stopLooking() {
                clearInterval(lookInterval);
            }
            
            lookRight.addEventListener('touchend', stopLooking);
            lookRight.addEventListener('touchcancel', stopLooking);
        });

        // Also update the mouse controls for desktop testing
        lookUp.addEventListener('mousedown', function() {
            const lookInterval = setInterval(function() {
                pitch -= lookSensitivity;
                pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
            }, 16);
            
            function stopLooking() {
                clearInterval(lookInterval);
            }
            
            lookUp.addEventListener('mouseup', stopLooking);
            lookUp.addEventListener('mouseleave', stopLooking);
        });

        lookDown.addEventListener('mousedown', function() {
            const lookInterval = setInterval(function() {
                pitch += lookSensitivity;
                pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
            }, 16);
            
            function stopLooking() {
                clearInterval(lookInterval);
            }
            
            lookDown.addEventListener('mouseup', stopLooking);
            lookDown.addEventListener('mouseleave', stopLooking);
        });

        lookLeft.addEventListener('mousedown', function() {
            const lookInterval = setInterval(function() {
                yaw += lookSensitivity;
            }, 16);
            
            function stopLooking() {
                clearInterval(lookInterval);
            }
            
            lookLeft.addEventListener('mouseup', stopLooking);
            lookLeft.addEventListener('mouseleave', stopLooking);
        });

        lookRight.addEventListener('mousedown', function() {
            const lookInterval = setInterval(function() {
                yaw -= lookSensitivity;
            }, 16);
            
            function stopLooking() {
                clearInterval(lookInterval);
            }
            
            lookRight.addEventListener('mouseup', stopLooking);
            lookRight.addEventListener('mouseleave', stopLooking);
        });

        // Update info text to include mobile controls info
        if (isMobile) {
            document.getElementById('info').innerHTML = 
                'Use on-screen controls to move and look around<br>' +
                '<div>Status: <span id="statusIndicator"></span> <span id="statusText">Connecting...</span></div>';
        }
    </script>
</body>
</html>
